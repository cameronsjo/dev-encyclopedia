---
title: XDG Base Directory
aliases:
  - XDG
  - XDG Specification
  - freedesktop.org Directories
tags:
  - cs
  - linux
  - standards
  - configuration
type: reference
status: complete
created: "2025-12-18"
---

# XDG Base Directory

Linux/Unix standard for where applications should store files.

## Overview

| Aspect | Details |
|--------|---------|
| **Full Name** | XDG Base Directory Specification |
| **Maintained By** | freedesktop.org |
| **Purpose** | Standardize config/data/cache locations |
| **Adopted By** | Most modern Linux applications |

## Why XDG Matters

### The Problem (Before XDG)

```
~/ (home directory)
├── .app1rc
├── .app2config
├── .app3/
│   ├── config
│   ├── cache
│   └── data
├── .randomapp
├── .another-app-settings.json
└── ... (dozens of dotfiles/directories)
```

**Issues:**

- Home directory cluttered with dotfiles
- No separation of config vs data vs cache
- Hard to back up just configs
- Hard to clear caches without losing data

### The Solution (With XDG)

```
~/
├── .config/          # XDG_CONFIG_HOME
│   ├── app1/
│   ├── app2/
│   └── app3/
├── .local/
│   ├── share/        # XDG_DATA_HOME
│   │   ├── app1/
│   │   └── app2/
│   └── state/        # XDG_STATE_HOME
│       └── app1/
└── .cache/           # XDG_CACHE_HOME
    ├── app1/
    └── app2/
```

## Environment Variables

### Core Directories

| Variable | Default | Purpose |
|----------|---------|---------|
| `XDG_CONFIG_HOME` | `~/.config` | User config files |
| `XDG_DATA_HOME` | `~/.local/share` | User data files |
| `XDG_STATE_HOME` | `~/.local/state` | User state files |
| `XDG_CACHE_HOME` | `~/.cache` | Non-essential cached data |
| `XDG_RUNTIME_DIR` | `/run/user/$UID` | Runtime files (sockets, etc.) |

### Search Paths

| Variable | Default | Purpose |
|----------|---------|---------|
| `XDG_CONFIG_DIRS` | `/etc/xdg` | System-wide config search path |
| `XDG_DATA_DIRS` | `/usr/local/share:/usr/share` | System-wide data search path |

## What Goes Where

### Config (`XDG_CONFIG_HOME`)

**User-editable settings that persist.**

```
~/.config/
├── git/
│   └── config           # Git configuration
├── nvim/
│   └── init.lua         # Neovim config
├── alacritty/
│   └── alacritty.toml   # Terminal config
├── fish/
│   └── config.fish      # Shell config
└── myapp/
    └── settings.json    # Your app's config
```

**Characteristics:**

- User might edit manually
- Should be version-controlled/backed up
- Portable between machines
- Small files, text-based preferred

### Data (`XDG_DATA_HOME`)

**Application data that should persist but isn't config.**

```
~/.local/share/
├── nvim/
│   ├── shada/           # Shared data (history, marks)
│   └── site/            # Plugins
├── fish/
│   └── fish_history     # Command history
├── applications/        # .desktop files
├── fonts/               # User fonts
└── myapp/
    ├── database.sqlite  # App database
    └── templates/       # User templates
```

**Characteristics:**

- Generated by app, not user-edited
- Should be backed up
- May be large
- Loss = loss of work/history

### State (`XDG_STATE_HOME`)

**State that persists but is less important than data.**

```
~/.local/state/
├── nvim/
│   └── undo/            # Undo history
├── bash/
│   └── history          # Bash history
└── myapp/
    ├── logs/            # Application logs
    └── recent-files     # Recently opened
```

**Characteristics:**

- Persists between runs
- OK to lose (inconvenient, not catastrophic)
- Logs, history, recent files
- Lower backup priority than data

### Cache (`XDG_CACHE_HOME`)

**Expendable cached data.**

```
~/.cache/
├── pip/                 # Python package cache
├── npm/                 # npm cache
├── thumbnails/          # Image thumbnails
├── fontconfig/          # Font cache
└── myapp/
    ├── http-cache/      # API response cache
    └── compiled/        # Compiled assets
```

**Characteristics:**

- Can be deleted anytime
- Regenerated automatically
- Improves performance
- Often large, don't back up

### Runtime (`XDG_RUNTIME_DIR`)

**Temporary files for current session only.**

```
/run/user/1000/          # $UID = 1000
├── pulse/               # PulseAudio socket
├── dbus/                # D-Bus socket
├── gnupg/               # GPG agent
└── myapp.sock           # Your app's socket
```

**Characteristics:**

- Must exist, be owned by user
- Cleared on logout/reboot
- tmpfs (RAM-based)
- Sockets, locks, PIDs
- Mode 0700 (user-only)

## Implementation

### Reading XDG Paths

```bash
# Bash - with fallbacks
config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/myapp"
data_dir="${XDG_DATA_HOME:-$HOME/.local/share}/myapp"
cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/myapp"
state_dir="${XDG_STATE_HOME:-$HOME/.local/state}/myapp"
```

```python
# Python
import os
from pathlib import Path

def get_config_dir(app_name: str) -> Path:
    base = os.environ.get('XDG_CONFIG_HOME', Path.home() / '.config')
    return Path(base) / app_name

def get_data_dir(app_name: str) -> Path:
    base = os.environ.get('XDG_DATA_HOME', Path.home() / '.local/share')
    return Path(base) / app_name

def get_cache_dir(app_name: str) -> Path:
    base = os.environ.get('XDG_CACHE_HOME', Path.home() / '.cache')
    return Path(base) / app_name

# Usage
config = get_config_dir('myapp')
config.mkdir(parents=True, exist_ok=True)
```

```javascript
// Node.js
const os = require('os');
const path = require('path');

function getConfigDir(appName) {
  const base = process.env.XDG_CONFIG_HOME ||
               path.join(os.homedir(), '.config');
  return path.join(base, appName);
}

function getDataDir(appName) {
  const base = process.env.XDG_DATA_HOME ||
               path.join(os.homedir(), '.local', 'share');
  return path.join(base, appName);
}

function getCacheDir(appName) {
  const base = process.env.XDG_CACHE_HOME ||
               path.join(os.homedir(), '.cache');
  return path.join(base, appName);
}
```

```go
// Go
package main

import (
    "os"
    "path/filepath"
)

func getConfigDir(appName string) string {
    if dir := os.Getenv("XDG_CONFIG_HOME"); dir != "" {
        return filepath.Join(dir, appName)
    }
    home, _ := os.UserHomeDir()
    return filepath.Join(home, ".config", appName)
}

func getDataDir(appName string) string {
    if dir := os.Getenv("XDG_DATA_HOME"); dir != "" {
        return filepath.Join(dir, appName)
    }
    home, _ := os.UserHomeDir()
    return filepath.Join(home, ".local", "share", appName)
}
```

```rust
// Rust - use the `dirs` crate
use dirs;

fn get_config_dir(app_name: &str) -> Option<std::path::PathBuf> {
    dirs::config_dir().map(|p| p.join(app_name))
}

fn get_data_dir(app_name: &str) -> Option<std::path::PathBuf> {
    dirs::data_dir().map(|p| p.join(app_name))
}

fn get_cache_dir(app_name: &str) -> Option<std::path::PathBuf> {
    dirs::cache_dir().map(|p| p.join(app_name))
}
```

### Libraries

| Language | Library |
|----------|---------|
| **Python** | `platformdirs`, `appdirs` |
| **Rust** | `dirs`, `directories` |
| **Go** | `os.UserConfigDir()`, `adrg/xdg` |
| **Node.js** | `env-paths`, `xdg-basedir` |
| **C/C++** | `glib` (g_get_user_config_dir) |

```python
# Python with platformdirs (recommended)
from platformdirs import user_config_dir, user_data_dir, user_cache_dir

config = user_config_dir("myapp")  # Cross-platform!
data = user_data_dir("myapp")
cache = user_cache_dir("myapp")
```

## Search Path Resolution

### Config File Lookup

```python
# Search order: user config, then system configs
import os
from pathlib import Path

def find_config(app_name: str, filename: str) -> Path | None:
    # User config first
    user_config = Path(os.environ.get('XDG_CONFIG_HOME',
                       Path.home() / '.config')) / app_name / filename
    if user_config.exists():
        return user_config

    # Then system configs
    system_dirs = os.environ.get('XDG_CONFIG_DIRS', '/etc/xdg').split(':')
    for dir in system_dirs:
        system_config = Path(dir) / app_name / filename
        if system_config.exists():
            return system_config

    return None
```

## Common Applications

| Application | Config | Data | Cache |
|-------------|--------|------|-------|
| **Git** | `~/.config/git/` | - | - |
| **Neovim** | `~/.config/nvim/` | `~/.local/share/nvim/` | `~/.cache/nvim/` |
| **Fish** | `~/.config/fish/` | `~/.local/share/fish/` | - |
| **VS Code** | `~/.config/Code/` | `~/.config/Code/` | `~/.cache/Code/` |
| **npm** | `~/.npmrc` | `~/.local/share/npm/` | `~/.cache/npm/` |
| **pip** | `~/.config/pip/` | - | `~/.cache/pip/` |

## Migration Tips

### Moving Legacy Dotfiles

```bash
# Example: migrate .myapprc to XDG
old_config="$HOME/.myapprc"
new_config="${XDG_CONFIG_HOME:-$HOME/.config}/myapp/config"

if [ -f "$old_config" ] && [ ! -f "$new_config" ]; then
    mkdir -p "$(dirname "$new_config")"
    mv "$old_config" "$new_config"
    echo "Migrated config to $new_config"
fi
```

### Backward Compatibility

```python
# Support both old and new locations
def get_config_path(app_name: str) -> Path:
    # Try XDG first
    xdg_config = Path(os.environ.get('XDG_CONFIG_HOME',
                      Path.home() / '.config')) / app_name / 'config'
    if xdg_config.exists():
        return xdg_config

    # Fall back to legacy location
    legacy = Path.home() / f'.{app_name}rc'
    if legacy.exists():
        return legacy

    # Default to XDG for new installs
    return xdg_config
```

## Best Practices

| Practice | Rationale |
|----------|-----------|
| **Always use XDG** | Don't clutter home directory |
| **Respect env vars** | User may have custom locations |
| **Create dirs as needed** | Don't assume they exist |
| **Use libraries** | Cross-platform, handles edge cases |
| **Separate concerns** | Config vs data vs cache |
| **Document locations** | Tell users where files are |

## Related

- [[macOS Development Basics]] — macOS equivalent paths
- [[Windows Development Basics]] — Windows equivalent paths
- [[Linux Distributions]] — Linux overview
- [[Computer Science MOC]] — CS topics
